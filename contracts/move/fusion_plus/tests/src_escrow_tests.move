#[test_only]
module fusion_plus::src_escrow_tests;

use fusion_plus::src_escrow::{Self, SrcEscrow, SignatureData, MerkleProofData};
use fusion_plus::immutables;
use fusion_plus::order::{Self, Order};
use sui::clock;
use sui::coin::{Self, Coin};
use sui::hash;
use sui::sui::SUI;
use sui::test_scenario::{Self as test, next_tx, ctx};
use sui::address;

// Mock coin types for testing
public struct USDC has drop, store {}
public struct WBTC has drop, store {}

// Helper function to create a test order
fun create_test_order<T: store>(
    receiver: vector<u8>,
    making_amount: u64,
    taking_amount: u64,
    deposit: Coin<T>,
    ctx: &mut TxContext,
) {
    order::create_order<T>(
        receiver, // receiver address
        making_amount, // making amount
        taking_amount, // taking amount
        @0x1, // maker_asset (USDC address)
        @0x2, // taker_asset (WBTC address)
        b"test_order_salt", // salt
        true, // is_partial_fill_allowed
        false, // is_multiple_fills_allowed
        deposit, // coin deposit
        1000000, // start_time (in ms)
        3600000, // duration (1 hour in ms)
        100, // initial_rate_bump
        vector::empty<u8>(), // points_and_time_deltas
        ctx,
    );
}

fun create_test_order_with_multiple_fills<T: store>(
        receiver: vector<u8>,
    making_amount: u64,
    taking_amount: u64,
    deposit: Coin<T>,
    ctx: &mut TxContext,
) {
    order::create_order<T>(
        receiver, // receiver address
        making_amount, // making amount
        taking_amount, // taking amount
        @0x1, // maker_asset (USDC address)
        @0x2, // taker_asset (WBTC address)
        b"test_order_salt", // salt
        true, // is_partial_fill_allowed
        true, // is_multiple_fills_allowed
        deposit, // coin deposit
        1000000, // start_time (in ms)
        3600000, // duration (1 hour in ms)
        100, // initial_rate_bump
        vector::empty<u8>(), // points_and_time_deltas
        ctx,
    );

}

// Helper function to create test signature data
// Note: For testing, this will be used with a modified verification approach
fun create_test_signature_data(): SignatureData {
    // Test Ed25519 keypair - in production this would be a real keypair
    let public_key = x"d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a";
    
    // Test signature - in production this would be generated by signing the order hash
    let signature = x"e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b";
    
    src_escrow::new_signature_data(public_key, signature, 0) // Ed25519 scheme = 0
}

// Helper function to create mock merkle proof data
fun create_mock_merkle_proof_data(secret: vector<u8>): MerkleProofData {
    let hashlock_info = hash::keccak256(&secret);
    let secret_hash = hash::keccak256(&secret); 
    let mut proof = vector::empty<vector<u8>>();
    vector::push_back(&mut proof, b"proof_element_1");
    vector::push_back(&mut proof, b"proof_element_2");
    
    src_escrow::new_merkle_proof_data(
        hashlock_info,
        secret_hash,
        0, // secret_index
        proof,
    )
}

#[test]
fun test_src_escrow_creation_with_order() {
    let admin = @0xA;
    let maker = @0xB;
    let taker = @0xC;

    let mut scenario = test::begin(admin);

    // Step 1: Create coins and order
    next_tx(&mut scenario, admin);
    {
        let ctx = ctx(&mut scenario);

        // Create coins for maker to deposit in order
        let usdc_coin_for_order = coin::mint_for_testing<USDC>(1000_00000000, ctx); // 1000 USDC for order
        transfer::public_transfer(usdc_coin_for_order, maker);

        // Create coins for taker to use in src escrow
        let sui_coin = coin::mint_for_testing<SUI>(100_000000000, ctx); // 100 SUI safety deposit
        transfer::public_transfer(sui_coin, taker);
    };

    // Step 2: Maker creates the order
    next_tx(&mut scenario, maker);
    {
        let usdc_coin_for_order = test::take_from_sender<Coin<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);

        create_test_order<USDC>(
            address::to_bytes(maker),
            1000_00000000, // making amount (smaller, safer number)
            100_00000000, // taking amount 
            usdc_coin_for_order,
            ctx,
        );
    };

    // Step 3: Taker creates src escrow
    next_tx(&mut scenario, taker);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        // Create test secret and hashlock
        let secret = b"test_secret_123";
        let secret_hash = hash::keccak256(&secret);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret_hash);
        
        let timelocks = immutables::new_src_timelocks(
            1000000, // deployment
            1000000 + 3600000, // withdrawal (1 hour later)
            1000000 + 7200000, // public_withdrawal (2 hours later) 
            1000000 + 14400000, // cancellation (4 hours later)
            1000000 + 18000000, // public_cancellation (5 hours later)
        );

        // Create src escrow
        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            1000_00000000, // deposit_amount (1000 USDC - same as order)
            sui_coin,
            timelocks,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Step 4: Verify both order and escrow were created
    next_tx(&mut scenario, admin);
    {
        // Check that order exists and is updated
        let order = test::take_shared<Order<USDC>>(&scenario);
        assert!(order::get_maker(&order) == maker, 0);
        test::return_shared(order);

        // Check that src escrow exists
        let escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        test::return_shared(escrow);
    };

    test::end(scenario);
}

#[test]
fun test_src_escrow_withdraw_to() {
    let admin = @0xA;
    let maker = @0xB;
    let taker = @0xC;
    let target = @0xD;

    let mut scenario = test::begin(admin);

    // Setup: Create order and escrow
    next_tx(&mut scenario, admin);
    {
        let ctx = ctx(&mut scenario);

        // Coins for maker's order
        let usdc_for_order = coin::mint_for_testing<USDC>(1500_00000000, ctx);
        transfer::public_transfer(usdc_for_order, maker);

        // Coins for taker's safety deposit
        let sui_coin = coin::mint_for_testing<SUI>(100_000000000, ctx);
        transfer::public_transfer(sui_coin, taker);
    };

    // Maker creates order
    next_tx(&mut scenario, maker);
    {
        let usdc_for_order = test::take_from_sender<Coin<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);

        create_test_order<USDC>(
            address::to_bytes(maker),
            1500_00000000, // making 1500 USDC
            150000000, // taking 1.5 WBTC
            usdc_for_order,
            ctx,
        );
    };

    let secret = b"withdrawal_secret";

    // Taker creates src escrow
    next_tx(&mut scenario, taker);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret);
        
        let timelocks = immutables::new_src_timelocks(
            1000000, // deployment
            1000000 + 3600000, // withdrawal
            1000000 + 7200000, // public_withdrawal
            1000000 + 14400000, // cancellation
            1000000 + 18000000, // public_cancellation
        );

        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            1000_00000000,
            sui_coin,
            timelocks,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Taker withdraws to target address during withdrawal period
    next_tx(&mut scenario, taker);
    {
        let mut escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);
        let mut clock = clock::create_for_testing(ctx);
        
        // Advance time to after withdrawal time (1 hour + 1 minute)
        clock::set_for_testing(&mut clock, 1000000 + 3600000 + 60000);

        // Withdraw to target address
        src_escrow::withdraw_to(&clock, &mut escrow, secret, target, ctx);

        test::return_shared(escrow);
        clock::destroy_for_testing(clock);
    };

    // Verify target received the funds
    next_tx(&mut scenario, target);
    {
        // Target should have received USDC
        let coin = test::take_from_sender<Coin<USDC>>(&scenario);
        assert!(coin::value(&coin) == 1000_00000000, 0);
        coin::burn_for_testing(coin);
    };

    test::end(scenario);
}

#[test]
fun test_src_escrow_public_withdraw() {
    let admin = @0xA;
    let maker = @0xB;
    let taker = @0xC;
    let public_user = @0xD;

    let mut scenario = test::begin(admin);

    // Setup escrow (similar to previous test)
    next_tx(&mut scenario, admin);
    {
        let ctx = ctx(&mut scenario);
        let usdc_for_order = coin::mint_for_testing<USDC>(500_00000000, ctx);
        let sui_coin = coin::mint_for_testing<SUI>(50_000000000, ctx);
        transfer::public_transfer(usdc_for_order, maker);
        transfer::public_transfer(sui_coin, taker);
    };

    next_tx(&mut scenario, maker);
    {
        let usdc_for_order = test::take_from_sender<Coin<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);

        create_test_order<USDC>(
            address::to_bytes(maker),
            500_00000000,
            50000000,
            usdc_for_order,
            ctx,
        );
    };

    let secret = b"public_secret";

    next_tx(&mut scenario, taker);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret);
        
        let timelocks = immutables::new_src_timelocks(
            1000000,
            1000000 + 3600000,
            1000000 + 7200000,
            1000000 + 14400000,
            1000000 + 18000000,
        );

        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            500_00000000,
            sui_coin,
            timelocks,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Public withdrawal during public period
    next_tx(&mut scenario, public_user);
    {
        let mut escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);
        let mut clock = clock::create_for_testing(ctx);
        
        // Advance time to after public withdrawal time (2 hours + 1 minute)
        clock::set_for_testing(&mut clock, 1000000 + 7200000 + 60000);

        // Anyone can withdraw during public period (funds go to taker)
        src_escrow::public_withdraw(&clock, &mut escrow, secret, ctx);

        test::return_shared(escrow);
        clock::destroy_for_testing(clock);
    };

    // Verify taker received the funds
    next_tx(&mut scenario, taker);
    {
        let coin = test::take_from_sender<Coin<USDC>>(&scenario);
        assert!(coin::value(&coin) == 500_00000000, 0);
        coin::burn_for_testing(coin);
    };

    test::end(scenario);
}

#[test]
fun test_src_escrow_cancel() {
    let admin = @0xA;
    let maker = @0xB;
    let taker = @0xC;

    let mut scenario = test::begin(admin);

    // Setup escrow
    next_tx(&mut scenario, admin);
    {
        let ctx = ctx(&mut scenario);
        let usdc_for_order = coin::mint_for_testing<USDC>(750_00000000, ctx);
        let sui_coin = coin::mint_for_testing<SUI>(75_000000000, ctx);
        transfer::public_transfer(usdc_for_order, maker);
        transfer::public_transfer(sui_coin, taker);
    };

    next_tx(&mut scenario, maker);
    {
        let usdc_for_order = test::take_from_sender<Coin<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);

        create_test_order<USDC>(
            address::to_bytes(maker),
            750_00000000,
            75000000,
            usdc_for_order,
            ctx,
        );
    };

    let secret = b"cancel_secret";
    let secret_hash = hash::keccak256(&secret);

    next_tx(&mut scenario, taker);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret_hash);
        
        let timelocks = immutables::new_src_timelocks(
            1000000,
            1000000 + 3600000,
            1000000 + 7200000,
            1000000 + 14400000,
            1000000 + 18000000,
        );

        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            750_00000000,
            sui_coin,
            timelocks,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Cancel after cancellation time
    next_tx(&mut scenario, taker);
    {
        let mut escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);
        let mut clock = clock::create_for_testing(ctx);
        
        // Advance time to after cancellation time (4 hours + 1 minute)
        clock::set_for_testing(&mut clock, 1000000 + 14400000 + 60000);

        // Taker can cancel and get safety deposit back
        let safety_deposit = src_escrow::cancel(&clock, &mut escrow, ctx);

        assert!(coin::value(&safety_deposit) == 75_000000000, 0);

        coin::burn_for_testing(safety_deposit);
        test::return_shared(escrow);
        clock::destroy_for_testing(clock);
    };

    test::end(scenario);
}

#[test]
fun test_src_escrow_public_cancel() {
    let admin = @0xA;
    let maker = @0xB;
    let taker = @0xC;
    let public_user = @0xD;

    let mut scenario = test::begin(admin);

    // Setup escrow
    next_tx(&mut scenario, admin);
    {
        let ctx = ctx(&mut scenario);
        let usdc_for_order = coin::mint_for_testing<USDC>(600_00000000, ctx);
        let sui_coin = coin::mint_for_testing<SUI>(60_000000000, ctx);
        transfer::public_transfer(usdc_for_order, maker);
        transfer::public_transfer(sui_coin, taker);
    };

    next_tx(&mut scenario, maker);
    {
        let usdc_for_order = test::take_from_sender<Coin<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);

        create_test_order<USDC>(
            address::to_bytes(maker),
            600_00000000,
            60000000,
            usdc_for_order,
            ctx,
        );
    };

    let secret = b"public_cancel_secret";
    let secret_hash = hash::keccak256(&secret);

    next_tx(&mut scenario, taker);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret_hash);
        
        let timelocks = immutables::new_src_timelocks(
            1000000,
            1000000 + 3600000,
            1000000 + 7200000,
            1000000 + 14400000,
            1000000 + 18000000,
        );

        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            600_00000000,
            sui_coin,
            timelocks,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Public cancel during public cancellation period
    next_tx(&mut scenario, public_user);
    {
        let mut escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);
        let mut clock = clock::create_for_testing(ctx);
        
        // Advance time to after public cancellation time (5 hours + 1 minute)
        clock::set_for_testing(&mut clock, 1000000 + 18000000 + 60000);

        // Anyone can cancel during public cancellation period
        let safety_deposit = src_escrow::public_cancel(&clock, &mut escrow, ctx);

        assert!(coin::value(&safety_deposit) == 60_000000000, 0);

        // Safety deposit goes to public caller
        transfer::public_transfer(safety_deposit, public_user);
        test::return_shared(escrow);
        clock::destroy_for_testing(clock);
    };

    // Verify public user received safety deposit
    next_tx(&mut scenario, public_user);
    {
        let safety_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        assert!(coin::value(&safety_coin) == 60_000000000, 0);
        coin::burn_for_testing(safety_coin);
    };

    test::end(scenario);
}

#[test]
#[expected_failure(abort_code = fusion_plus::src_escrow::EInvalidTaker)]
fun test_src_escrow_withdraw_wrong_caller() {
    let admin = @0xA;
    let maker = @0xB;
    let taker = @0xC;
    let wrong_caller = @0xD;

    let mut scenario = test::begin(admin);

    // Setup escrow (abbreviated)
    next_tx(&mut scenario, admin);
    {
        let ctx = ctx(&mut scenario);
        let usdc_for_order = coin::mint_for_testing<USDC>(300_00000000, ctx);
        let sui_coin = coin::mint_for_testing<SUI>(30_000000000, ctx);
        transfer::public_transfer(usdc_for_order, maker);
        transfer::public_transfer(sui_coin, taker);
    };

    next_tx(&mut scenario, maker);
    {
        let usdc_for_order = test::take_from_sender<Coin<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);

        create_test_order<USDC>(
            address::to_bytes(maker),
            300_00000000,
            30000000,
            usdc_for_order,
            ctx,
        );
    };

    let secret = b"caller_test_secret";
    let secret_hash = hash::keccak256(&secret);

    next_tx(&mut scenario, taker);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret_hash);
        
        let timelocks = immutables::new_src_timelocks(
            1000000,
            1000000 + 3600000,
            1000000 + 7200000,
            1000000 + 14400000,
            1000000 + 18000000,
        );

        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            300_00000000,
            sui_coin,
            timelocks,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Try to withdraw with wrong caller (should fail)
    next_tx(&mut scenario, wrong_caller);
    {
        let mut escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);
        let mut clock = clock::create_for_testing(ctx);
        
        // Advance time to withdrawal period
        clock::set_for_testing(&mut clock, 1000000 + 3600000 + 60000);

        // This should abort with EInvalidTaker
        src_escrow::withdraw_to(&clock, &mut escrow, secret, wrong_caller, ctx);

        test::return_shared(escrow);
        clock::destroy_for_testing(clock);
    };

    test::end(scenario);
}

#[test]
#[expected_failure(abort_code = fusion_plus::src_escrow::EInvalidTime)]
fun test_src_escrow_withdraw_too_early() {
    let admin = @0xA;
    let maker = @0xB;
    let taker = @0xC;

    let mut scenario = test::begin(admin);

    // Setup escrow (abbreviated)
    next_tx(&mut scenario, admin);
    {
        let ctx = ctx(&mut scenario);
        let usdc_for_order = coin::mint_for_testing<USDC>(200_00000000, ctx);
        let sui_coin = coin::mint_for_testing<SUI>(20_000000000, ctx);
        transfer::public_transfer(usdc_for_order, maker);
        transfer::public_transfer(sui_coin, taker);
    };

    next_tx(&mut scenario, maker);
    {
        let usdc_for_order = test::take_from_sender<Coin<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);

        create_test_order<USDC>(
            address::to_bytes(maker),
            200_00000000,
            20000000,
            usdc_for_order,
            ctx,
        );
    };

    let secret = b"timing_test_secret";
    let secret_hash = hash::keccak256(&secret);

    next_tx(&mut scenario, taker);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret_hash);
        
        let timelocks = immutables::new_src_timelocks(
            1000000,
            1000000 + 3600000,
            1000000 + 7200000,
            1000000 + 14400000,
            1000000 + 18000000,
        );

        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            200_00000000,
            sui_coin,
            timelocks,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Try to withdraw too early (should fail)
    next_tx(&mut scenario, taker);
    {
        // Don't advance time - still before withdrawal time
        let mut escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        // This should abort with EInvalidTime
        src_escrow::withdraw_to(&clock, &mut escrow, secret, taker, ctx);

        test::return_shared(escrow);
        clock::destroy_for_testing(clock);
    };

    test::end(scenario);
}

#[test]
fun test_src_escrow_creation_with_multiple_fills() {
    let admin = @0xA;
    let maker = @0xB;
    let taker1 = @0xC;
    let taker2 = @0xD;

    let mut scenario = test::begin(admin);

    // Step 1: Create coins for maker and takers
    next_tx(&mut scenario, admin);
    {
        let ctx = ctx(&mut scenario);

        // Create coins for maker to deposit in order (larger amount for multiple fills)
        let usdc_coin_for_order = coin::mint_for_testing<USDC>(2000_00000000, ctx); // 2000 USDC for order
        transfer::public_transfer(usdc_coin_for_order, maker);

        // Create coins for first taker's safety deposit
        let sui_coin1 = coin::mint_for_testing<SUI>(100_000000000, ctx); // 100 SUI safety deposit
        transfer::public_transfer(sui_coin1, taker1);

        // Create coins for second taker's safety deposit  
        let sui_coin2 = coin::mint_for_testing<SUI>(80_000000000, ctx); // 80 SUI safety deposit
        transfer::public_transfer(sui_coin2, taker2);
    };

    // Step 2: Maker creates an order that allows multiple fills
    next_tx(&mut scenario, maker);
    {
        let usdc_coin_for_order = test::take_from_sender<Coin<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);

        create_test_order_with_multiple_fills<USDC>(
            address::to_bytes(maker),
            2000_00000000, // making amount - 2000 USDC
            200_00000000, // taking amount - 200 WBTC (10:1 ratio)
            usdc_coin_for_order,
            ctx,
        );
    };

    // Step 3: First taker creates src escrow for partial fill
    next_tx(&mut scenario, taker1);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        // Create test secret and hashlock for first taker
        let secret1 = b"taker1_secret_123";
        let secret_hash1 = hash::keccak256(&secret1);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret_hash1);
        
        let timelocks1 = immutables::new_src_timelocks(
            1000000, // deployment
            1000000 + 3600000, // withdrawal (1 hour later)
            1000000 + 7200000, // public_withdrawal (2 hours later) 
            1000000 + 14400000, // cancellation (4 hours later)
            1000000 + 18000000, // public_cancellation (5 hours later)
        );

        // Create src escrow for partial fill (60% of the order)
        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            1200_00000000, // deposit_amount (1200 USDC - 60% of order)
            sui_coin,
            timelocks1,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Step 4: Second taker creates src escrow for remaining portion
    next_tx(&mut scenario, taker2);
    {
        let mut order = test::take_shared<Order<USDC>>(&scenario);
        let sui_coin = test::take_from_sender<Coin<SUI>>(&scenario);
        let ctx = ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);

        // Create different secret for second taker
        let secret2 = b"taker2_secret_456";
        let secret_hash2 = hash::keccak256(&secret2);

        let signature_data = create_test_signature_data();
        let merkle_data = create_mock_merkle_proof_data(secret_hash2);
        
        let timelocks2 = immutables::new_src_timelocks(
            1000000, // deployment
            1000000 + 3600000, // withdrawal (1 hour later)
            1000000 + 7200000, // public_withdrawal (2 hours later) 
            1000000 + 14400000, // cancellation (4 hours later)
            1000000 + 18000000, // public_cancellation (5 hours later)
        );

        // Create src escrow for remaining portion (40% of the order)
        src_escrow::create_new_for_testing<USDC>(
            &clock,
            merkle_data,
            &mut order,
            signature_data,
            800_00000000, // deposit_amount (800 USDC - 40% of order, totaling 100%)
            sui_coin,
            timelocks2,
            ctx,
        );

        test::return_shared(order);
        clock::destroy_for_testing(clock);
    };

    // Step 5: Verify both src escrows were created successfully
    next_tx(&mut scenario, admin);
    {
        // Check that order exists and has been partially filled
        let order = test::take_shared<Order<USDC>>(&scenario);
        assert!(order::get_maker(&order) == maker, 0);
        // Order should reflect that it has been completely filled (1200 + 800 = 2000)
        test::return_shared(order);

        // Check that both src escrows exist
        let escrow1 = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let escrow2 = test::take_shared<SrcEscrow<USDC>>(&scenario);
        
        test::return_shared(escrow1);
        test::return_shared(escrow2);
    };

    // Step 6: Test withdrawal from first escrow
    next_tx(&mut scenario, taker1);
    {
        let mut escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);
        let mut clock = clock::create_for_testing(ctx);
        
        // Advance time to withdrawal period
        clock::set_for_testing(&mut clock, 1000000 + 3600000 + 60000);

        let secret1 = b"taker1_secret_123";
        
        // First taker withdraws their portion to themselves
        src_escrow::withdraw_to(&clock, &mut escrow, secret1, taker1, ctx);

        test::return_shared(escrow);
        clock::destroy_for_testing(clock);
    };

    // Step 7: Verify first taker received their funds
    next_tx(&mut scenario, taker1);
    {
        let coin = test::take_from_sender<Coin<USDC>>(&scenario);
        assert!(coin::value(&coin) == 1200_00000000, 0); // Should receive 1200 USDC
        coin::burn_for_testing(coin);
    };

    // Step 8: Test withdrawal from second escrow  
    next_tx(&mut scenario, taker2);
    {
        let mut escrow = test::take_shared<SrcEscrow<USDC>>(&scenario);
        let ctx = ctx(&mut scenario);
        let mut clock = clock::create_for_testing(ctx);
        
        // Time is already advanced from previous withdrawal
        clock::set_for_testing(&mut clock, 1000000 + 3600000 + 120000);

        let secret2 = b"taker2_secret_456";
        
        // Second taker withdraws their portion to themselves
        src_escrow::withdraw_to(&clock, &mut escrow, secret2, taker2, ctx);

        test::return_shared(escrow);
        clock::destroy_for_testing(clock);
    };

    // Step 9: Verify second taker received their funds
    next_tx(&mut scenario, taker2);
    {
        let coin = test::take_from_sender<Coin<USDC>>(&scenario);
        assert!(coin::value(&coin) == 800_00000000, 0); // Should receive 800 USDC
        coin::burn_for_testing(coin);
    };

    test::end(scenario);
}
